#!/bin/bash
# mer-sdk-chroot

# TODO
#
# Support a Mer clean setup (ie no .oscrc)
# Support multiple shells (ie split setup/entry)

usage()
{
    cat <<EOF
    usage: sudo <enter|on|off> $1 [-u <user>] [-m <all|none|root|home>] [-r <SDK root path>]
       The Mer chroot SDK

       -u  System user to link into SDK (not needed if using sudo)
       -m  Devices to bind mount from host: none, all (default)
           root, home
       -r The root of the SDK to use - normally derived from the
          pathname of $0

EOF
    return 0
}

if [[ $EUID -ne 0 ]]; then
    exec sudo $0 "$@"
    echo "$0 must be run as root and sudo failed; exiting"
    exit 1
fi

# Use the SUDO value if present
user=$SUDO_USER || true;

bind_mount_root="yes";
bind_mount_home="yes";
while getopts "u:m:r:" opt; do
    case $opt in
	u ) user=$OPTARG;;
	m )
	    case $OPTARG in
		all) ;;
		home)
		    bind_mount_root="no";;
		root)
		    bind_mount_home="no";;
		none)
		    bind_mount_root="no";
		    bind_mount_home="no";;
		*)  echo "Only 'none', 'all' or 'home' are permitted for -m"
		    usage
		    exit 1;;
	    esac ;;
	r ) sdkroot=$OPTARG;;
	\? ) usage
            exit 1;;
	: ) echo "Option -$OPTARG requires an argument." >&2
	    usage
	    exit 1;;
	* ) usage
            exit 1;;
    esac
done
shift $(($OPTIND - 1))

if [[ -z "${sdkroot}" ]] ; then
    sdkroot=$(dirname $(readlink -f $0))
else
    sdkroot=$(readlink -f $sdkroot)
fi

if [[ -f ${sdkroot}/etc/MerSDK ]] ; then
    echo "${sdkroot} is not a Mer SDK root directory"
    usage
    exit 1
fi

if [[ -z $user ]] ; then
    echo "$0 expects to be run as root using sudo"
    echo "User could not be obtained from \$SUDO_USER, if running as root,"
    echo "please use -u <user>"
    echo
    usage
    exit 1
fi

# From now on, exit if variables not set
set -u

# Make sure normal users can use any dirs we make
umask 022

################################################################
# Mount
prepare_mountpoints() {
    # Setup sdkroot as a bind mountpoint on itself to permit
    # --make-unbindable
    mount --bind $sdkroot/ $sdkroot/
    mount --make-unbindable $sdkroot

    echo "Mounting system directories..."
    mount --bind /proc ${sdkroot}/proc
    mount --bind /proc/sys/fs/binfmt_misc ${sdkroot}/proc/sys/fs/binfmt_misc
    mount --bind /sys ${sdkroot}/sys
    mount --bind /dev ${sdkroot}/dev
    mount --bind /dev/pts ${sdkroot}/dev/pts
    mount --bind /dev/shm/ ${sdkroot}/dev/shm/
    mount --bind /var/lib/dbus ${sdkroot}/var/lib/dbus
    mount --bind /var/run/dbus ${sdkroot}/var/run/dbus

    if [[ $bind_mount_root == "yes" ]] ; then
	echo "Mounting / as /parentroot"
	mkdir -p ${sdkroot}/parentroot
	mount --rbind / ${sdkroot}/parentroot/
    fi

    mkdir -p ${sdkroot}/lib/modules/`uname -r`
    mount --bind /lib/modules/`uname -r` ${sdkroot}/lib/modules/`uname -r`

}

prepare_user() {
    # getent is probably best for user data
    sed -i -e "/^${user}:/d" ${sdkroot}/etc/passwd
    getent passwd $user >> ${sdkroot}/etc/passwd
    HOMEDIR=$(getent passwd $user | cut -f6 -d:)

    if [[ $bind_mount_home == "yes" ]] ; then
	echo "Mounting home directory: ${HOMEDIR}"
	mkdir -p ${sdkroot}${HOMEDIR}
	mount --bind ${HOMEDIR} ${sdkroot}${HOMEDIR}
	mount --make-unbindable ${sdkroot}${HOMEDIR}
    fi
    echo "$user ALL=NOPASSWD: ALL" > ${sdkroot}/etc/sudoers.d/$user
    chmod 0440 ${sdkroot}/etc/sudoers.d/$user
}

prepare_etc() {
    cp /etc/resolv.conf ${sdkroot}/etc/resolv.conf

    [[ -d ${sdkroot}/etc/ssl/certs ]] || {
	mkdir -p ${sdkroot}/etc/ssl/certs
	cp -aL /etc/ssl/certs ${sdkroot}/etc/ssl/
    }
}

################################################################
# Umount

err_cleanup() {
    echo
    echo 'Something went wrong during cleanup.'
    echo 'Retrying umounts but manual check is required'
    echo '- press return to confirm'
    echo
    read dummy
    # Now retry cleanup
    set +e
    cleanup
}

umounterrs=""
warn_umount(){
    echo
    echo "Error executing umount of $mountpoint"
    umounterrs="$umounterrs\n$mountpoint"
}

try_umount() {
    mountpoint=$1
    shift
    trap "warn_umount" ERR
    umount "$@" $mountpoint
    trap - ERR
}

cleanup () {
    # We need to detect all mountpoints inside our chroot.
    mountpoints_r=$(perl -w -ne "print \"\$1\n\" if m\"^\S* ${sdkroot}(/\S*) \";" /proc/mounts | sort -r)

    echo "Unmounting all directories... ($(echo \"${mountpoints_r}\" | wc -w) found)"

    # umount in reverse order
    for mp in ${mountpoints_r}; do
	try_umount ${sdkroot}$mp/
    done

    # umount the self-bind mount we use to apply the --make-unbindable
    # When this script is run in umount mode the shell has a
    # filehandle open into the self-mount for it - this results in a
    # device busy and hence needs a lazy umount
    try_umount ${sdkroot}/ -l

    # Report any errors found
    if [[ $umounterrs ]]; then
	echo
	echo "Errors encountered when unmounting the following mountpoints"
	echo -e $umounterrs
    fi
}

################################################################
# utility
ensure_mounted() {
    [[ -e ${sdkroot}/.sdkoptions ]] || {
	cat <<EOF
This SDK ( ${sdkroot} ) does not appear to be mounted.
Have you run $0 mount?

(Check /proc/self/mounts to be sure.)
EOF
	exit 1;
    }
}
ensure_not_mounted() {
    [[ -e ${sdkroot}/.sdkoptions ]] && {
	cat <<EOF
This SDK ( ${sdkroot} ) is already mounted.
If you are sure this is not an error and /proc/self/mounts has no mountpoints under it then remove ${sdkroot}/.sdkoptions and try again.
EOF
	exit 1;
    }

}
stash_mount_options() {
    cat <<EOF > ${sdkroot}/.sdkoptions
user="${user}"
HOMEDIR="${HOMEDIR}"
EOF
}
get_mount_options() {
    [[ -e ${sdkroot}/.sdkoptions ]] && {
	source ${sdkroot}/.sdkoptions
    }
}

################

setup_user_hooks(){
    # Access any user hooks
    [[ -e $HOMEDIR/.mersdkrc ]] && . $HOMEDIR/.mersdkrc
}

run_user_hook() {
    hook=$1
    [[ $(type -t $hook) == "function" ]] && {
	echo "User hook $hook"
	$hook
    }
}
################

add_pid_to_active_chroot_list() {
    mkdir -p $sdkroot/.active_chroots/
    touch $sdkroot/.active_chroots/$$
}
rm_pid_from_active_chroot_list() {
    rm $sdkroot/.active_chroots/$$
}
ensure_active_chroot_list_is_empty() {
    mkdir -p $sdkroot/.active_chroots/
    pids=$(ls $sdkroot/.active_chroots/)
    [[ -z "$pids" ]] || {
	echo "There appears to be $(echo $pids | wc -w) chroot(s) still using this SDK"
	echo "Process(es): $pids"
	exit 1;
    }
}

################################################################

action=${1:-enter}

case "$action" in
    enter )
        # setarch is used so uname -a will report i386 - this allows
        # osc to work
	ensure_mounted
	get_mount_options
	setup_user_hooks
	echo "Entering chroot as $user"
	run_user_hook enter_sdk
	add_pid_to_active_chroot_list
	setarch i386 chroot ${sdkroot} su -s /bin/bash -l $user -- -c "exec bash --init-file /mer-bash-setup -i"
	rm_pid_from_active_chroot_list
	run_user_hook leave_sdk
	;;

    mount  )
	ensure_not_mounted
	trap "err_cleanup; exit" INT TERM EXIT
        prepare_mountpoints   # host / and data and /proc and similar
	prepare_user          # in /etc/passwd
	setup_user_hooks      # (after prepare so HOMEDIR is known)
	prepare_etc           # resolv.conf and ssl certs
	run_user_hook mount_sdk
	stash_mount_options   # for use when umounting

	cat <<EOF
${sdkroot} is now setup with mountpoints to make it easier to use as a Mer SDK.
EOF
	trap - INT TERM EXIT
	;;

    umount|unmount )
	ensure_mounted
	ensure_active_chroot_list_is_empty
	get_mount_options
	rm ${sdkroot}/.sdkoptions
	setup_user_hooks
	trap "err_cleanup; exit" INT TERM EXIT
        # Call cleanup manually - if an error occurs then warn and
        # retry
	run_user_hook umount_sdk
	cleanup
	trap - INT TERM EXIT
	;;
    * )
	echo "$action not recognised"
	;;
esac
